# -*- coding: utf-8 -*-
"""Google Colab - LLM-werkwijze Pydantic en journalistieke quotes _FINAL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W2MpSma1yPE-DJPAXZnvTlcDGFCPEv1e

Deze werkwijze laat zien hoe binnen het NWO-gesubsidieerde PHD-traject 'De framing van een systeemtechnologie ‚Äì Narratieven en verbeeldingen over kunstmatige intelligentie in Nederlandse journalistieke media' data verzameld is uit journalistieke artikelen over AI (1960-2024) uit de databases NexisUni en Delpher.

Het project is een samenwerking tussen Universiteit Utrecht en Fontys Journalistiek. De werkwijze toont een eerste aanzet voor het extraheren van quotes (wat bronnen zeggen binnen een journalistieke tekstproductie) in journalistieke artikelen. De werkwijze is ontworpen door docentonderzoeker en PHD-kandidaat Jessy de Cooker. Dank aan Chris Newell (BBC), Anna Vissens (The Guardian), Jeroen van de Nieuwenhof (Tolkie) en Chris van der Lee (Universiteit van Tilburg) voor journalistiek en technisch advies en het delen van hun inzichten, en Danielle Arets (Fontys Journalistiek) en Bruce Mutsvairo en Imar de Vries (Universiteit Utrecht) voor hun begeleiding in dit PHD-traject.

Tilburg, september 2025, Jessy de Cooker
"""

!pip install --upgrade openai

!pip install pydantic #spacy
#!python -m spacy download nl_core_news_lg

import os

# Eigen API sleutel hieronder
os.environ["OPENAI_API_KEY"] = "<>" ###vul hier jouw eigen API-key in

from openai import OpenAI
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

"""Met tools zoals Pydantic kun je vooraf defini√´ren hoe een geldig antwoord eruit moet zien. Pydantic is een Python-tool die helpt om ongestructureerde data om te zetten in betrouwbare, voorspelbare Python-objecten. Het werkt met type-annotaties: je definieert een BaseModel waarin je bijvoorbeeld vastlegt dat title een string moet zijn en published_at een datetime. Zodra je er data in stopt, van een API, CSV of taalmodel, checkt Pydantic automatisch of die klopt.  

In het model hieronder voer ik vast de categorie√´n van output in en hoe ik de output geordend wil hebben. Ik wil dat het systeem uiteindelijk 5 verschillende typen quotes genereert, en dat de output geordend is in deze volgorde: content (inhoud van de quote), source (bron die de quote uitspreekt), cue (werkwoord van de quote), quote_type (type quote)
"""

from enum import Enum
from typing import List, Optional
from pydantic import BaseModel, Field

class QuoteType(str, Enum):
    DIRECT = "direct"
    SENTENCE_END = "sentence_end"
    PARAPHRASE = "paraphrase"
    INDIRECT = "indirect"
    SPLIT = "split"
class Quote(BaseModel):
    content: str = Field(..., description="De geciteerde tekst, tussen aanhalingstekens.")
    source: Optional[str] = Field(None, description="Naam van de spreker of bron.")
    cue: Optional[str] = Field(None, description="Signaalwoord dat aangeeft dat iemand iets zegt.")
    quote_type: QuoteType = Field(..., alias="type")  # ‚Üê 'type' uit JSON ‚Üí 'quote_type' intern

class ArticleWithQuotes(BaseModel):
    quotes: List[Quote] = Field(..., description="Lijst van alle citaten uit het artikel.")

"""Ik heb met Google Drive gewerkt voor dit specifieke voorbeeld. Hier kun je jouw persoonlijke werkwijze om data in te laden kiezen."""

from google.colab import drive
drive.mount('/content/drive')

drive_dir = "<pad>" #Kies hier jouw eigen file-path

"""Hieronder een test om te kijken of de data goed ingeladen wordt. Er volgt een lijst van alle artikeltitels."""

import glob
import os

# üîç Zoek en sorteer alle .txt bestanden
filenames = sorted(glob.glob(os.path.join(drive_dir, "*.txt")))
print(f"üìÅ Gevonden bestanden: {len(filenames)}")

# üìÑ Toon bestandsnamen
print("üìÑ Gesorteerde bestandsnamen:")
for f in filenames:
    print("-", os.path.basename(f))

"""Opnieuw een test of de bestanden correct uitgelezen worden. Hier worden van een willekeurig bestand in de betreffende map de eerste 1000 tekens getoond."""

import random
keuze = random.choice(filenames)
with open(keuze, 'r', encoding='utf-8') as f:
        tekst = f.read()

print(f"Bestand: {keuze}\n---\n{tekst[:1000]}")  # Toon max 1000 karakters als voorbeeld

"""Hier wordt aangegeven hoeveel artikelen per batch geanalyseerd worden."""

text_batches = []
batch_size = 10  # pas aan indien gewenst

current_batch = []
for filename in filenames:
    with open(filename, "r", encoding="utf-8") as f:
        text = f.read().strip()
        current_batch.append((filename, text))
        if len(current_batch) == batch_size:
            text_batches.append(current_batch)
            current_batch = []

# Voeg laatste batch toe als deze kleiner is
if current_batch:
    text_batches.append(current_batch)

print(f"Aantal batches: {len(text_batches)}")

print(f"üß™ Batch {i+1} totaal tokens (geschat): {sum(len(t[1].split()) for t in batch)}")

"""Hier de python-input en de prompt voor de quote-detectie."""

import json
import pandas as pd
from pydantic import ValidationError
import os

all_quotes = []
invalid_quotes = []

for i, batch in enumerate(text_batches):
    print(f"\nüîÑ Verwerk batch {i+1}/{len(text_batches)}")

    for filename, text in batch:
        print(f"\nüìÑ Bestand: {filename}")

        prompt = f"""
Haal alle citaten uit de volgende Nederlandstalige nieuwsartikelteksten.

Geef een JSON-object met √©√©n veld "quotes", dat een lijst bevat van citaten.
Elk citaat is een JSON-object met de volgende velden:

- "source": de naam van de spreker of bron (persoon of organisatie),
- "cue": het signaalwoord dat aanduidt dat iemand iets zegt (zoals 'zei', 'aldus', 'verklaarde'),
- "content": de geciteerde tekst, tussen aanhalingstekens,
- "type": het type citaat, op basis van onderstaande definities

Gebruik uitsluitend citaten met expliciete bronvermelding. Negeer ironische of hypothetische aanhalingstekens, slogans, vage bronnen of citaten zonder duidelijke cue of spreker. Haal uitsluitend citaten op die letterlijk en volledig voorkomen in de brontekst. Verzamel geen eigen interpretaties, aanvullingen of ingekorte weergaves.


### DEFINITIES VAN TYPE QUOTES:

1. **direct**
- De cue (bijv. 'zei', 'stelde', 'verklaarde') introduceert een letterlijk citaat.
- Meestal volgt er een dubbele punt v√≥√≥r het citaat.
- Voorbeeld:
  _Vooruitblikkend stelde Rutte: ‚ÄúEen stem op de PVV is een verloren stem.‚Äù_

2. **sentence_end**
- De quote staat aan het begin van de zin, gevolgd door de cue en bron.
- De cue kan binnen of buiten de aanhalingstekens vallen, afhankelijk van stijl.
- Voorbeeld:
  _‚ÄúOngekende nonsens,‚Äù zegt Theo Weterings._

3. **paraphrase**
- De uitspraak wordt samengevat of gedeeltelijk overgenomen.
- Kan tussen aanhalingstekens staan, maar is geen letterlijk citaat.
- Voorbeeld:
  _Van Bommel zei dat PSV een ‚Äúkapitale blunder‚Äù had begaan._

4. **indirect**
- Geen aanhalingstekens. De inhoud is samengevat of omschreven.
- Meestal voorafgegaan door een beschrijvende introductie.
- Voorbeeld:
  _Hij veroordeelde het avontuur: ‚ÄúAlsof Nederland een speeltuin is.‚Äù_

5. **split**
- Het citaat wordt onderbroken door de cue of extra uitleg.
- Bestaat uit twee tekstsegmenten.
- Voorbeeld:
  _‚ÄúWe gaan investeren,‚Äù aldus Kist, ‚Äúen dat is nodig.‚Äù_

Text:
{text}
"""

        try:
            completion = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "Je bent een assistent voor het extraheren van citaten die gestructureerde gegevens retourneert. Haal uitsluitend citaten op die letterlijk en volledig voorkomen in de brontekst. Analyseer de tekst van begin tot eind en retourneer in die volgorde de output. Verzamel geen eigen interpretaties, aanvullingen of ingekorte weergaves. Retourneer altijd slechts √©√©n geldig JSON-object met een 'quotes'-lijst. Elk citaat bevat de bron, cue, inhoud en type. Voeg geen uitleg of commentaar toe."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0
            )

            response_text = completion.choices[0].message.content

            if "```" in response_text:
                response_text = response_text.split("```")[1]
                response_text = response_text.replace("json", "").strip()

            print(" Gedeeltelijke response:\n", response_text[:500])

            data = json.loads(response_text)
            raw_quotes = data.get("quotes", [])

            for q in raw_quotes:
                try:
                    quote = Quote(**q)
                    quote_dict = quote.dict()
                    quote_dict["filename"] = os.path.basename(filename)
                    all_quotes.append(quote_dict)
                except ValidationError as ve:
                    print(f" Ongeldige quote: {ve}")
                    invalid_quotes.append(q)

        except Exception as e:
            print(f" Fout bij bestand {filename}: {e}")
            if 'response_text' in locals():
                print("‚Üí response_text:\n", response_text)

# Samenvatting
print(f"\n Totaal geaccepteerde quotes: {len(all_quotes)}")
print(f" Totaal overgeslagen (ongeldige) quotes: {len(invalid_quotes)}")

"""Met deze cel converteer je het de JSON-output van Pydantic naar een csv-bestand dat je zelf - naar voorkeur - kunt verwerken in een dataverwerker van jouw voorkeur."""

df = pd.DataFrame(all_quotes)

if not df.empty:
    # Sorteer op bestandsnaam voor consistente volgorde
    df = df.sort_values(by="filename")

    # üíæ Exporteer CSV met ; als scheidingsteken
    df.to_csv("test.csv", index=False, sep=";")
    print(f" {len(df)} quotes ge√´xporteerd naar 'test.csv'")
else:
    print(" Geen quotes gevonden. Controleer Cel 5.")